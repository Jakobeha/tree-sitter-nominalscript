==================================
Various nominalscript (hard) | Ambient declarations
==================================

declare class Error {
  constructor: Function; () => Void
}

declare var foo; Integer;

declare const bar = "baz";

declare function greet(greeting; String); Void;

declare namespace myLib {
    function makeGreeting(s; String); Greeting;
    let greetings; String[];

    interface LogOptions {
      verbose?; Boolean;
    }
    interface AlertOptions {
      modal; Boolean;
      title?; String;
      color?: string; Color;
    }
}

declare class Greeter {
  constructor(greeting; String);

  greeting; String;
  showGreeting(); Void;
}

declare module Foo.Bar { export var foo; };

declare module Foo {
  break;
  continue;
  debugger;
  do { } while (true);
  for (x in null) { }
  for (;;) { }
  if (true) { } else { }
  1;
  return;
  switch (x) {
      case 1:
          break;
      default:
          break;
  }
  throw "hello";
  try { }
  catch (e) { }
  finally { }
}

---

(program
  (ambient_declaration
    (class_declaration
      (type_identifier)
      (class_body
        (public_field_definition
          (property_identifier)
          (type_annotation
            (type_identifier))
          (nominal_type_annotation
            (function_nominal_type
              (nominal_formal_parameters)
              (nominal_type_identifier)))))))
  (ambient_declaration
    (variable_declaration
      (variable_declarator
        (identifier)
        (nominal_type_annotation
          (nominal_type_identifier)))))
  (ambient_declaration
    (lexical_declaration
      (variable_declarator
        (identifier)
        (string
          (string_fragment)))))
  (ambient_declaration
    (function_signature
      (identifier)
      (formal_parameters
        (required_parameter
          (identifier)
          (nominal_type_annotation
            (nominal_type_identifier))))
      (nominal_type_annotation
        (nominal_type_identifier))))
  (ambient_declaration
    (internal_module
      (identifier)
      (statement_block
        (function_signature
          (identifier)
          (formal_parameters
            (required_parameter
              (identifier)
              (nominal_type_annotation
                (nominal_type_identifier))))
          (nominal_type_annotation
            (nominal_type_identifier)))
        (lexical_declaration
          (variable_declarator
            (identifier)
            (nominal_type_annotation
              (array_nominal_type
                (nominal_type_identifier)))))
        (interface_declaration
          (type_identifier)
          (object_type
            (property_signature
              (property_identifier)
              (nominal_type_annotation
                (nominal_type_identifier)))))
        (interface_declaration
          (type_identifier)
          (object_type
            (property_signature
              (property_identifier)
              (nominal_type_annotation
                (nominal_type_identifier)))
            (property_signature
              (property_identifier)
              (nominal_type_annotation
                (nominal_type_identifier)))
            (property_signature
              (property_identifier)
              (type_annotation
                (predefined_type))
              (nominal_type_annotation
                (nominal_type_identifier))))))))
  (ambient_declaration
    (class_declaration
      (type_identifier)
      (class_body
        (method_signature
          (property_identifier)
          (formal_parameters
            (required_parameter
              (identifier)
              (nominal_type_annotation
                (nominal_type_identifier)))))
        (public_field_definition
          (property_identifier)
          (nominal_type_annotation
            (nominal_type_identifier)))
        (method_signature
          (property_identifier)
          (formal_parameters)
          (nominal_type_annotation
            (nominal_type_identifier))))))
  (ambient_declaration
    (module
      (nested_identifier
        (identifier)
        (identifier))
      (statement_block
        (export_statement
          (variable_declaration
            (variable_declarator
              (identifier)))))))
  (empty_statement)
  (ambient_declaration
    (module
      (identifier)
      (statement_block
        (break_statement)
        (continue_statement)
        (debugger_statement)
        (do_statement
          (statement_block)
          (parenthesized_expression
            (true)))
        (for_in_statement
          (identifier)
          (null)
          (statement_block))
        (for_statement
          (empty_statement)
          (empty_statement)
          (statement_block))
        (if_statement
          (parenthesized_expression
            (true))
          (statement_block)
          (else_clause
            (statement_block)))
        (expression_statement
          (number))
        (return_statement)
        (switch_statement
          (parenthesized_expression
            (identifier))
          (switch_body
            (switch_case
              (number)
              (break_statement))
            (switch_default
              (break_statement))))
        (throw_statement
          (string
            (string_fragment)))
        (try_statement
          (statement_block)
          (catch_clause
            (identifier)
            (statement_block))
          (finally_clause
            (statement_block)))))))


==================================================
Nominalscript in catch clauses
==================================================

try {}
catch (e; Any) {}
finally {}

try {}
catch (e: any; Error) {}
finally {}

---

(program
  (try_statement
    (statement_block)
    (catch_clause
      (identifier)
      (nominal_type_annotation
        (nominal_type_identifier))
      (statement_block))
    (finally_clause
      (statement_block)))
  (try_statement
    (statement_block)
    (catch_clause
      (identifier)
      (type_annotation
        (predefined_type))
      (nominal_type_annotation
        (nominal_type_identifier))
      (statement_block))
    (finally_clause
      (statement_block))))

==================================================
NominalScript method return values | Flow-style ambient class declarations with commas
==================================================

declare interface IFoo {
  bar(); Integer,
  baz(); IBaz,
}

declare class Foo {
  bar(): number; Integer,
  baz(); Baz,
}

---

(program
  (ambient_declaration
    (interface_declaration
      (type_identifier)
      (object_type
        (method_signature
          (property_identifier)
          (formal_parameters)
          (nominal_type_annotation
            (nominal_type_identifier)))
        (method_signature
          (property_identifier)
          (formal_parameters)
          (nominal_type_annotation
            (nominal_type_identifier))))))
  (ambient_declaration
    (class_declaration
      (type_identifier)
      (class_body
        (method_signature
          (property_identifier)
          (formal_parameters)
          (type_annotation
            (predefined_type))
          (nominal_type_annotation
            (nominal_type_identifier)))
        (method_signature
          (property_identifier)
          (formal_parameters)
          (nominal_type_annotation
            (nominal_type_identifier)))))))

==================================
A nominalscript annotation in a module.exports | Flow module.exports declarations
==================================

declare module.exports: {
  foo; String;
}

---

(program
  (ambient_declaration
    (property_identifier)
    (object_type
      (property_signature
        (property_identifier)
        (nominal_type_annotation
          (nominal_type_identifier))))))

==================================
Simple nominalscript with a generic | Ambient exports
==================================

export default function point(x; Integer, y: number; Integer) {
    return { x, y };
}

// a comment

export default class A {}

export async function readFile(filename: string): Promise<Buffer>; Promise<Buffer>

---

(program
  (export_statement
    (function_declaration
      (identifier)
      (formal_parameters
        (required_parameter
          (identifier)
          (nominal_type_annotation
            (nominal_type_identifier)))
        (required_parameter
          (identifier)
          (type_annotation
            (predefined_type))
          (nominal_type_annotation
            (nominal_type_identifier))))
      (statement_block
        (return_statement
          (object
            (shorthand_property_identifier)
            (shorthand_property_identifier))))))
  (comment)
  (export_statement
    (class_declaration
      (type_identifier)
      (class_body)))
  (export_statement
    (function_signature
      (identifier)
      (formal_parameters
        (required_parameter
          (identifier)
          (type_annotation
            (predefined_type))))
      (type_annotation
        (generic_type
          (type_identifier)
          (type_arguments
            (type_identifier))))
      (nominal_type_annotation
        (generic_nominal_type
          (nominal_type_identifier)
          (nominal_type_arguments
            (nominal_type_identifier)))))))

==================================
Nominalscript after typeof (this is a case where you may actually want both a TypeScript and NominalScript definition, usually it's redundant)
==================================

declare class Linter {
    static findConfiguration: typeof findConfiguration; Configuration;
}

---

(program
  (ambient_declaration
    (class_declaration
      (type_identifier)
      (class_body
        (public_field_definition
          (property_identifier)
          (type_annotation
            (type_query
              (identifier)))
          (nominal_type_annotation
            (nominal_type_identifier)))))))

==================================
Export nominal types
==================================

export { Foo, ;Bar, type Baz };
export { ;Qux as Abc };

---

(program
  (export_statement
    (export_clause
      (export_specifier
        (identifier))
      (export_specifier
        (nominal_import_export_specifier
          (nominal_type_identifier)))
      (export_specifier
        (identifier))))
  (export_statement
    (export_clause
      (export_specifier
        (nominal_import_export_specifier
          (nominal_type_identifier)
          (identifier))))))

==================================
Import nominal types
==================================

import { Foo, ;Bar, type Baz } from 'qux';
import { ;Abc as Def, Ghi as Jkl, typeof Mno as Pqr } from 'stu'

---

(program
  (import_statement
    (import_clause
      (named_imports
        (import_specifier
          (identifier))
        (import_specifier
          (nominal_import_export_specifier
            (nominal_type_identifier)))
        (import_specifier
          (identifier))))
    (string
      (string_fragment)))
  (import_statement
    (import_clause
      (named_imports
        (import_specifier
          (nominal_import_export_specifier
            (nominal_type_identifier)
            (identifier)))
        (import_specifier
          (identifier)
          (identifier))
        (import_specifier
          (identifier)
          (identifier))))
    (string
      (string_fragment))))

==================================
Import nominal types in modules
==================================

module C {
  import { Foo, ;Bar, type Baz } from 'qux';
  import { ;Abc as Def, Ghi as Jkl, typeof Mno as Pqr } from 'stu'
}

---

(program
  (module
    (identifier)
    (statement_block
      (import_statement
        (import_clause
          (named_imports
            (import_specifier
              (identifier))
            (import_specifier
              (nominal_import_export_specifier
                (nominal_type_identifier)))
            (import_specifier
              (identifier))))
        (string
          (string_fragment)))
      (import_statement
        (import_clause
          (named_imports
            (import_specifier
              (nominal_import_export_specifier
                (nominal_type_identifier)
                (identifier)))
            (import_specifier
              (identifier)
              (identifier))
            (import_specifier
              (identifier)
              (identifier))))
        (string
          (string_fragment))))))

==================================
More nominalscript annotations | Property signatures with accessibility modifiers
==================================

export interface IAppState {
  public readonly users: ReadonlyArray<User>; User
  public saveUser(user; User); Void
}

export class CloningRepository {
  public readonly id; Integer = CloningRepositoryID++
}


---

(program
  (export_statement
    (interface_declaration
      (type_identifier)
      (object_type
        (property_signature
          (accessibility_modifier)
          (property_identifier)
          (type_annotation
            (generic_type
              (type_identifier)
              (type_arguments
                (type_identifier))))
          (nominal_type_annotation
            (nominal_type_identifier)))
        (method_signature
          (accessibility_modifier)
          (property_identifier)
          (formal_parameters
            (required_parameter
              (identifier)
              (nominal_type_annotation
                (nominal_type_identifier))))
          (nominal_type_annotation
            (nominal_type_identifier))))))
  (export_statement
    (class_declaration
      (type_identifier)
      (class_body
        (public_field_definition
          (accessibility_modifier)
          (property_identifier)
          (nominal_type_annotation
            (nominal_type_identifier))
          (update_expression
            (identifier)))))))

==================================
Nominal type declarations
==================================

type; Foo
type; Bar: number
type; Baz; String
type; Qux guard(a) {
  return a instanceof number
}
type; Abc: number guard(a) {
  return a % 2 === 0
}
type; Def; String guard(a) {
  return a.length > 0
}
type; Ghi: number; Integer; Float guard(a) {
  return a % 1 === 0
}
type; Jkl<T>: Mno<T>[]; Pqr<T, Integer, Stu[]>; T guard(a) {
  if (a === 5) {
    return true
  } else {
    return a instanceof number
  }
}

---

(program
  (nominal_type_declaration
    (nominal_type_identifier))
  (nominal_type_declaration
    (nominal_type_identifier)
    (type_annotation
      (predefined_type)))
  (nominal_type_declaration
    (nominal_type_identifier)
    (nominal_type_annotation
      (nominal_type_identifier)))
  (nominal_type_declaration
    (nominal_type_identifier)
    (nominal_type_guard
      (identifier)
      (statement_block
        (return_statement
          (binary_expression
            (identifier)
            (identifier))))))
  (nominal_type_declaration
    (nominal_type_identifier)
    (type_annotation
      (predefined_type))
    (nominal_type_guard
      (identifier)
      (statement_block
        (return_statement
          (binary_expression
            (binary_expression
              (identifier)
              (number))
            (number))))))
  (nominal_type_declaration
    (nominal_type_identifier)
    (nominal_type_annotation
      (nominal_type_identifier))
    (nominal_type_guard
      (identifier)
      (statement_block
        (return_statement
          (binary_expression
            (member_expression
              (identifier)
              (property_identifier))
            (number))))))
  (nominal_type_declaration
    (nominal_type_identifier)
    (type_annotation
      (predefined_type))
    (nominal_type_annotation
      (nominal_type_identifier))
    (nominal_type_annotation
      (nominal_type_identifier))
    (nominal_type_guard
      (identifier)
      (statement_block
        (return_statement
          (binary_expression
            (binary_expression
              (identifier)
              (number))
            (number))))))
  (nominal_type_declaration
    (nominal_type_identifier)
    (nominal_type_parameters
      (nominal_type_identifier))
    (type_annotation
      (array_type
        (generic_type
          (type_identifier)
          (type_arguments
            (type_identifier)))))
    (nominal_type_annotation
      (generic_nominal_type
        (nominal_type_identifier)
        (nominal_type_arguments
          (nominal_type_identifier)
          (nominal_type_identifier)
          (array_nominal_type
            (nominal_type_identifier)))))
    (nominal_type_annotation
      (nominal_type_identifier))
    (nominal_type_guard
      (identifier)
      (statement_block
        (if_statement
          (parenthesized_expression
            (binary_expression
              (identifier)
              (number)))
          (statement_block
            (return_statement
              (true)))
          (else_clause
            (statement_block
              (return_statement
                (binary_expression
                  (identifier)
                  (identifier))))))))))

==================================
More nominalscript | Ambient module declarations
==================================

module Promise {
    var on; {}
    export function resolve<;R>(value?; Thenable<R>); Promise<R>;
}

declare module "example"

declare module "example" { }

---

(program
  (module
    (identifier)
    (statement_block
      (variable_declaration
        (variable_declarator
          (identifier)
          (nominal_type_annotation
            (object_nominal_type))))
      (export_statement
        (function_signature
          (identifier)
          (type_parameters
            (nominal_type_identifier_denoted
              (nominal_type_identifier)))
          (formal_parameters
            (optional_parameter
              (identifier)
              (nominal_type_annotation
                (generic_nominal_type
                  (nominal_type_identifier)
                  (nominal_type_arguments
                    (nominal_type_identifier))))))
          (nominal_type_annotation
            (generic_nominal_type
              (nominal_type_identifier)
              (nominal_type_arguments
                (nominal_type_identifier))))))))
  (ambient_declaration
    (module
      (string
        (string_fragment))))
  (ambient_declaration
    (module
      (string
        (string_fragment))
      (statement_block))))

=================================
Weird but valid place for a nominalscript annotation
=================================

x = { name, description, private: (private; Private), public: (public: Public; Public) }

---

(program
  (expression_statement
    (assignment_expression
      (identifier)
      (object
        (shorthand_property_identifier)
        (shorthand_property_identifier)
        (pair
          (property_identifier)
          (parenthesized_expression
            (identifier)
            (nominal_type_annotation
              (nominal_type_identifier))))
        (pair
          (property_identifier)
          (parenthesized_expression
            (identifier)
            (type_annotation
              (type_identifier))
            (nominal_type_annotation
              (nominal_type_identifier))))))))

=================================
Nominal wrapper expressions
=================================

Array<Integer>;foo()
Array<Integer>;foo(1, 2, 3)
Array<Float>!;(5 + bar)
Array<Float>!;5 + bar

---

(program
  (expression_statement
    (call_expression
      (nominal_wrap_expression
        (generic_nominal_type
          (nominal_type_identifier)
          (nominal_type_arguments
            (nominal_type_identifier)))
        (identifier))
      (arguments)))
  (expression_statement
    (call_expression
      (nominal_wrap_expression
        (generic_nominal_type
          (nominal_type_identifier)
          (nominal_type_arguments
            (nominal_type_identifier)))
        (identifier))
      (arguments
        (number)
        (number)
        (number))))
  (expression_statement
    (nominal_wrap_unchecked_expression
      (generic_nominal_type
        (nominal_type_identifier)
        (nominal_type_arguments
          (nominal_type_identifier)))
      (parenthesized_expression
        (binary_expression
          (number)
          (identifier)))))
  (expression_statement
    (binary_expression
      (nominal_wrap_unchecked_expression
        (generic_nominal_type
          (nominal_type_identifier)
          (nominal_type_arguments
            (nominal_type_identifier)))
        (number))
      (identifier))))

=================================
Nominal generics
=================================

export interface Foo {
  export function OrderedMap<;K, ;V>(iter; IterableKeyed<K, V>); OrderedMap<K, V>;
}

---

(program
  (export_statement
    (interface_declaration
      (type_identifier)
      (object_type
        (export_statement
          (function_signature
            (identifier)
            (type_parameters
              (nominal_type_identifier_denoted
                (nominal_type_identifier))
              (nominal_type_identifier_denoted
                (nominal_type_identifier)))
            (formal_parameters
              (required_parameter
                (identifier)
                (nominal_type_annotation
                  (generic_nominal_type
                    (nominal_type_identifier)
                    (nominal_type_arguments
                      (nominal_type_identifier)
                      (nominal_type_identifier))))))
            (nominal_type_annotation
              (generic_nominal_type
                (nominal_type_identifier)
                (nominal_type_arguments
                  (nominal_type_identifier)
                  (nominal_type_identifier))))))))))

=================================
Complex nominal types
=================================

declare namespace moment {
  export var formatFunction: () => string; () => FormattedString;

  export var x; String;
  export var foo; {
    bar; Bar,
    baz<Qux>(Def<Qux>)
    ghi; (Jkl) => {
      nmo; Pqr
    },
    stu; [Integer, String]
  }
}

var a: {
  b: number,
  c: string,
  d: boolean
}; {
  b; B,
  c; C,
  d; D
} = {
  b,
  c,
  d
}

var fooBar = [Foo, Bar];[foo, bar]

---

(program
  (ambient_declaration
    (internal_module
      (identifier)
      (statement_block
        (export_statement
          (variable_declaration
            (variable_declarator
              (identifier)
              (type_annotation
                (function_type
                  (formal_parameters)
                  (predefined_type)))
              (nominal_type_annotation
                (function_nominal_type
                  (nominal_formal_parameters)
                  (nominal_type_identifier))))))
        (export_statement
          (variable_declaration
            (variable_declarator
              (identifier)
              (nominal_type_annotation
                (nominal_type_identifier)))))
        (export_statement
          (variable_declaration
            (variable_declarator
              (identifier)
              (nominal_type_annotation
                (object_nominal_type
                  (nominal_property_signature
                    (property_identifier)
                    (nominal_type_annotation
                      (nominal_type_identifier)))
                  (nominal_method_signature
                    (property_identifier)
                    (nominal_type_parameters
                      (nominal_type_identifier))
                    (nominal_formal_parameters
                      (generic_nominal_type
                        (nominal_type_identifier)
                        (nominal_type_arguments
                          (nominal_type_identifier)))))
                  (nominal_property_signature
                    (property_identifier)
                    (nominal_type_annotation
                      (function_nominal_type
                        (nominal_formal_parameters
                          (nominal_type_identifier))
                        (object_nominal_type
                          (nominal_property_signature
                            (property_identifier)
                            (nominal_type_annotation
                              (nominal_type_identifier)))))))
                  (nominal_property_signature
                    (property_identifier)
                    (nominal_type_annotation
                      (tuple_nominal_type
                        (nominal_type_identifier)
                        (nominal_type_identifier))))))))))))
  (variable_declaration
    (variable_declarator
      (identifier)
      (type_annotation
        (object_type
          (property_signature
            (property_identifier)
            (type_annotation
              (predefined_type)))
          (property_signature
            (property_identifier)
            (type_annotation
              (predefined_type)))
          (property_signature
            (property_identifier)
            (type_annotation
              (predefined_type)))))
      (nominal_type_annotation
        (object_nominal_type
          (nominal_property_signature
            (property_identifier)
            (nominal_type_annotation
              (nominal_type_identifier)))
          (nominal_property_signature
            (property_identifier)
            (nominal_type_annotation
              (nominal_type_identifier)))
          (nominal_property_signature
            (property_identifier)
            (nominal_type_annotation
              (nominal_type_identifier)))))
      (object
        (shorthand_property_identifier)
        (shorthand_property_identifier)
        (shorthand_property_identifier))))
  (variable_declaration
    (variable_declarator
      (identifier)
      (array
        (identifier)
        (identifier))))
  (expression_statement
    (array
      (identifier)
      (identifier))))

===========================================
More nominalscript annotations | Method declarations with keywords as names
===========================================

class Foo {
  private async(); {}
  get(); Result {};
  private set(plugin) {};
}

---

(program
  (class_declaration
    (type_identifier)
    (class_body
      (method_signature
        (accessibility_modifier)
        (property_identifier)
        (formal_parameters)
        (nominal_type_annotation
          (object_nominal_type)))
      (method_definition
        (property_identifier)
        (formal_parameters)
        (nominal_type_annotation
          (nominal_type_identifier))
        (statement_block))
      (method_definition
        (accessibility_modifier)
        (property_identifier)
        (formal_parameters
          (required_parameter
            (identifier)))
        (statement_block)))))

=======================================
NominalScript method with optional param
=======================================

function foo(xyz?: number; Integer) {}
function bar(xyz? ; Number) {}
function baz(xyz?; Number) {}

---

(program
  (function_declaration
    (identifier)
    (formal_parameters
      (optional_parameter
        (identifier)
        (type_annotation
          (predefined_type))
        (nominal_type_annotation
          (nominal_type_identifier))))
    (statement_block))
  (function_declaration
    (identifier)
    (formal_parameters
      (optional_parameter
        (identifier)
        (nominal_type_annotation
          (nominal_type_identifier))))
    (statement_block))
  (function_declaration
    (identifier)
    (formal_parameters
      (optional_parameter
        (identifier)
        (nominal_type_annotation
          (nominal_type_identifier))))
    (statement_block)))

=======================================
More nominalscript annotations | Classes with method signatures
=======================================

class Foo {
  public async waitFor<T, ;T>(func: () => T | Promise<T | undefined>; () => T, accept?: (result: T) => boolean | Promise<boolean>; (T) => Boolean, timeoutMessage?: String, retryCount?; Number); Promise<T>;

  public readonly async bar?<;T>();
  private static bar();
  private static async bar(); T;
}

---

(program
  (class_declaration
    (type_identifier)
    (class_body
      (method_signature
        (accessibility_modifier)
        (property_identifier)
        (type_parameters
          (type_parameter
            (type_identifier))
          (nominal_type_identifier_denoted
            (nominal_type_identifier)))
        (formal_parameters
          (required_parameter
            (identifier)
            (type_annotation
              (function_type
                (formal_parameters)
                (union_type
                  (type_identifier)
                  (generic_type
                    (type_identifier)
                    (type_arguments
                      (union_type
                        (type_identifier)
                        (literal_type
                          (undefined))))))))
            (nominal_type_annotation
              (function_nominal_type
                (nominal_formal_parameters)
                (nominal_type_identifier))))
          (optional_parameter
            (identifier)
            (type_annotation
              (function_type
                (formal_parameters
                  (required_parameter
                    (identifier)
                    (type_annotation
                      (type_identifier))))
                (union_type
                  (predefined_type)
                  (generic_type
                    (type_identifier)
                    (type_arguments
                      (predefined_type))))))
            (nominal_type_annotation
              (function_nominal_type
                (nominal_formal_parameters
                  (nominal_type_identifier))
                (nominal_type_identifier))))
          (optional_parameter
            (identifier)
            (type_annotation
              (type_identifier)))
          (optional_parameter
            (identifier)
            (nominal_type_annotation
              (nominal_type_identifier))))
        (nominal_type_annotation
          (generic_nominal_type
            (nominal_type_identifier)
            (nominal_type_arguments
              (nominal_type_identifier)))))
      (method_signature
        (accessibility_modifier)
        (property_identifier)
        (type_parameters
          (nominal_type_identifier_denoted
            (nominal_type_identifier)))
        (formal_parameters))
      (method_signature
        (accessibility_modifier)
        (property_identifier)
        (formal_parameters))
      (method_signature
        (accessibility_modifier)
        (property_identifier)
        (formal_parameters)
        (nominal_type_annotation
          (nominal_type_identifier))))))

=======================================
Classes with property names as strings or numbers
=======================================

class Foo {
  static 2; String;
  public static 2; String = 'string';
  public static readonly 'hello'?; Integer = 'string';
  static readonly 'hello'?; Integer = 'string';
  readonly 'hello'?; Integer = 'string';
}

---

(program
  (class_declaration
    (type_identifier)
    (class_body
      (public_field_definition
        (number)
        (nominal_type_annotation
          (nominal_type_identifier)))
      (public_field_definition
        (accessibility_modifier)
        (number)
        (nominal_type_annotation
          (nominal_type_identifier))
        (string
          (string_fragment)))
      (public_field_definition
        (accessibility_modifier)
        (string
          (string_fragment))
        (nominal_type_annotation
          (nominal_type_identifier))
        (string
          (string_fragment)))
      (public_field_definition
        (string
          (string_fragment))
        (nominal_type_annotation
          (nominal_type_identifier))
        (string
          (string_fragment)))
      (public_field_definition
        (string
          (string_fragment))
        (nominal_type_annotation
          (nominal_type_identifier))
        (string
          (string_fragment))))))

=======================================
Classes with decorators
=======================================

@baz @bam class Foo {
  @foo static 2; String;
  @bar.buzz(grue) public static 2; String = 'string';
  @readonly readonly 'hello'?; Integer = 'string';
  @readonly fooBar(@required param; Any, @optional param2?; Any) {
  }
}

---

(program
  (class_declaration
    (decorator
      (identifier))
    (decorator
      (identifier))
    (type_identifier)
    (class_body
      (decorator
        (identifier))
      (public_field_definition
        (number)
        (nominal_type_annotation
          (nominal_type_identifier)))
      (decorator
        (call_expression
          (member_expression
            (identifier)
            (property_identifier))
          (arguments
            (identifier))))
      (public_field_definition
        (accessibility_modifier)
        (number)
        (nominal_type_annotation
          (nominal_type_identifier))
        (string
          (string_fragment)))
      (decorator
        (identifier))
      (public_field_definition
        (string
          (string_fragment))
        (nominal_type_annotation
          (nominal_type_identifier))
        (string
          (string_fragment)))
      (decorator
        (identifier))
      (method_definition
        (property_identifier)
        (formal_parameters
          (required_parameter
            (decorator
              (identifier))
            (identifier)
            (nominal_type_annotation
              (nominal_type_identifier)))
          (optional_parameter
            (decorator
              (identifier))
            (identifier)
            (nominal_type_annotation
              (nominal_type_identifier))))
        (statement_block)))))

=======================================
Classes with methods with and without trailing semicolons on one line
=======================================

class Foo<Bar> extends Baz { bar; Integer = 5; static one(a; String) { return a; }; two(b; String); String { return b; } three; Integer; four: 4; Integer }

---

(program
  (class_declaration
    (type_identifier)
    (type_parameters
      (type_parameter
        (type_identifier)))
    (class_heritage
      (extends_clause
        (identifier)))
    (class_body
      (public_field_definition
        (property_identifier)
        (nominal_type_annotation
          (nominal_type_identifier))
        (number))
      (method_definition
        (property_identifier)
        (formal_parameters
          (required_parameter
            (identifier)
            (nominal_type_annotation
              (nominal_type_identifier))))
        (statement_block
          (return_statement
            (identifier))))
      (method_definition
        (property_identifier)
        (formal_parameters
          (required_parameter
            (identifier)
            (nominal_type_annotation
              (nominal_type_identifier))))
        (nominal_type_annotation
          (nominal_type_identifier))
        (statement_block
          (return_statement
            (identifier))))
      (public_field_definition
        (property_identifier)
        (nominal_type_annotation
          (nominal_type_identifier)))
      (public_field_definition
        (property_identifier)
        (type_annotation
          (literal_type
            (number)))
        (nominal_type_annotation
          (nominal_type_identifier))))))

=======================================
More nominalscript annotations | Abstract classes
=======================================

abstract class Foo {
}

abstract class Animal {
    readonly abstract prop: string;
    requiredProp!; String;
    abstract makeSound(): void;
    abstract get readonlyProp(); String;
    protected abstract readonlyProp?(); String;
    move(): void {
        console.log("roaming the earth...");
    }
}

@bar
abstract class Foo {
}

---

(program
  (abstract_class_declaration
    (type_identifier)
    (class_body))
  (abstract_class_declaration
    (type_identifier)
    (class_body
      (public_field_definition
        (property_identifier)
        (type_annotation
          (predefined_type)))
      (public_field_definition
        (property_identifier)
        (nominal_type_annotation
          (nominal_type_identifier)))
      (abstract_method_signature
        (property_identifier)
        (formal_parameters)
        (type_annotation
          (predefined_type)))
      (abstract_method_signature
        (property_identifier)
        (formal_parameters)
        (nominal_type_annotation
          (nominal_type_identifier)))
      (abstract_method_signature
        (accessibility_modifier)
        (property_identifier)
        (formal_parameters)
        (nominal_type_annotation
          (nominal_type_identifier)))
      (method_definition
        (property_identifier)
        (formal_parameters)
        (type_annotation
          (predefined_type))
        (statement_block
          (expression_statement
            (call_expression
              (member_expression
                (identifier)
                (property_identifier))
              (arguments
                (string
                  (string_fragment)))))))))
  (abstract_class_declaration
    (decorator
      (identifier))
    (type_identifier)
    (class_body)))

==================================
Definite assignment assertions
==================================

var a!; B;
let a!; B;

---

(program
  (variable_declaration
    (variable_declarator
      (identifier)
      (nominal_type_annotation
        (nominal_type_identifier))))
  (lexical_declaration
    (variable_declarator
      (identifier)
      (nominal_type_annotation
        (nominal_type_identifier)))))

==================================
Nullable nominal types
==================================

var a; B?;
let a; () => [String, B][]?;

---

(program
  (variable_declaration
    (variable_declarator
      (identifier)
      (nominal_type_annotation
        (nullable_nominal_type
          (nominal_type_identifier)))))
  (lexical_declaration
    (variable_declarator
      (identifier)
      (nominal_type_annotation
        (function_nominal_type
          (nominal_formal_parameters)
          (nullable_nominal_type
            (array_nominal_type
              (tuple_nominal_type
                (nominal_type_identifier)
                (nominal_type_identifier)))))))))

====================================
Top-level export
====================================

export type; Foo; Boolean guard(x) { return x }

---

(program
  (export_statement
    (nominal_type_declaration
      (nominal_type_identifier)
      (nominal_type_annotation
        (nominal_type_identifier))
      (nominal_type_guard
        (identifier)
        (statement_block
          (return_statement
            (identifier)))))))
